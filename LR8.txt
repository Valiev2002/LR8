#include <iostream>
#include <string>

struct VVS
{
    std::string name = "VVS_0";
    std::string klass = "not stated";
    int vvs_number = -1;
};

std::ostream& operator<< (std::ostream& out, const VVS&vvs)
{
    out << std::endl;
    out << "VVS_" <<vvs.vvs_number << " \"" << vvs.name << "\"" << std::endl;
    out << "Class of the object: " << vvs.klass << std::endl;
    return out;
}

bool operator!=(const VVS& left, const VVS& right)
{
    return left.vvs_number != right.vvs_number;
}

template <typename T>
struct list_element
{
    T value;
    list_element* le_prev = nullptr;
    list_element* le_next = nullptr;
};

template <typename T>
struct list_struct
{
    list_element<T>* l_begin;
    list_element<T>* l_end;
};

template <typename T>
void constructor_l(list_struct<T>& l)
{
    l.l_begin = nullptr;
    l.l_end = nullptr;
}

template <typename T>
unsigned int size_of_l(list_struct<T>& l)
{
    list_element<T>* current = new list_element<T>;
    current = l.l_begin;
    if (current == nullptr) return 0;
    else {
        unsigned int counter = 1;
        while (current != l.l_end) {
            counter++;
            current = current->le_next;
        }
        return counter;
    }
}

template <typename T>
void push_begin(list_struct<T>& l, T n)
{
    if (l.l_begin == nullptr) {
       list_element<T>* newl_e = new list_element<T>;
        newl_e->value = n;
        l.l_begin = newl_e;
        l.l_end = newl_e;
        newl_e->le_next = newl_e;
        newl_e->le_prev = newl_e;
    }
    else {
       list_element<T>* newl_e = new list_element<T>;
        newl_e->value = n;
        l.l_begin->le_prev = newl_e;
        newl_e->le_next = l.l_begin;
        l.l_begin = newl_e;
        l.l_begin->le_prev = l.l_end;
    }
}

template <typename T>
void push_end(list_struct<T>& l, T n)
{
    if (l.l_begin == nullptr) {
        list_element<T>* newl_e = new list_element<T>;
        newl_e->value = n;
        l.l_begin = newl_e;
        l.l_end = newl_e;
        newl_e->le_next = newl_e;
        newl_e->le_prev = newl_e;
    }
    else {
        list_element<T>* newl_e = new list_element<T>;
        newl_e->value = n;
        l.l_end->le_next = newl_e;
        newl_e->le_prev = l.l_end;
        l.l_end = newl_e;
        l.l_end->le_next = l.l_begin;
    }
}

template <typename T>
void insert_index(list_struct<T>& l, T n, unsigned int i)
{
    unsigned int counter = 0;
    list_element<T>*current = new list_element<T>;
    current = l.l_begin;
    while (counter != i)
    {
        current = current->le_next;
        ++counter;
    }
   list_element<T>* newl_e = new list_element<T>;
    newl_e->value = n;
    newl_e->le_prev = current->le_prev;
    current->le_prev->le_next = newl_e;
    current->le_prev = newl_e;
    newl_e->le_next = current;
}

template <typename T>
void insert_pointer(list_struct<T>& l, T n,list_element<T>* i) {
    list_element<T> *current = new list_element<T>;
    current = l.l_begin;
    while (current != i) current = current->le_next;
    list_element<T> *newl_e = new list_element<T>;
    newl_e->value = n;
    newl_e->le_prev = current->le_prev;
    current->le_prev->le_next = newl_e;
    current->le_prev = newl_e;
    newl_e->le_next = current;
}

template<typename T>
T pop_begin(list_struct<T>&l)
{
    l.l_end ->le_next = l.l_begin->le_next;
    l.l_begin->le_next->le_prev = l.l_end;
    T rez = l.l_begin->value;
    list_element<T> *tmp = new list_element<T>;
    tmp = l.l_begin->le_next;
    delete l.l_begin;
    l.l_begin = tmp;
    return rez;
}


template <typename T>
T pop_end(list_struct<T>& l)
{
    l.l_end->le_prev->le_next = l.l_begin;
    l.l_begin->le_prev = l.l_end->le_prev;
    T rez = l.l_end->value;
   list_element<T>* tmp = new list_element<T>;
    tmp = l.l_end->le_prev;
    delete l.l_end;
    l.l_end = tmp;
    return rez;
}

template <typename T>
T pop_index(list_struct<T>& l, unsigned int i)
{
    unsigned int counter = 0;
    list_element<T>* current = new list_element<T>;
    current = l.l_begin;
    std::cout << i << std::endl;
    while (counter != i)
    {
        current = current->le_next;
        std::cout << counter << " ";
        ++counter;
    }
    T rez = current->value;
    current->le_prev->le_next = current->le_next;
    current->le_next->le_prev = current->le_prev;
    delete current;
    return rez;
}

template <typename T>
T pop_index_pointer(list_struct<T>& l, list_element<T>* i)
{
   list_element<T>* current = new list_element<T>;
    current = l.l_begin;
    while (current != i) current = current->le_next;
    T rez = current->value;
    current->le_prev->le_next = current->le_next;
    current->le_next->le_prev = current->le_prev;
    delete current;
    return rez;
}

template <typename T>
T find_value(list_struct<T>& l, unsigned int i)
{
    unsigned int counter = 0;
    list_element<T>* current = new list_element<T>;
    current = l.l_begin;
    while (counter != i)
    {
        current = current->le_next;
        counter++;
    }
    return current->value;
}

template <typename T>
unsigned int find_pos(list_struct<T>& l, T n)
{
    list_element<T>* current = new list_element<T>;
    current = l.l_begin;
    unsigned int i = 0;
    while (current->value != n) {
        ++i;
        current = current->le_next;
    }
    return i;
}

template <typename T>
void show_list(list_struct<T>& l)
{
   list_element<T>* current = new list_element<T>;
    current = l.l_begin;
    unsigned int i = 0;
    std::cout << " " << std::endl;
    std::cout << i << " " << current->value << std::endl;
    ++i;
    while (current != l.l_end) {
        current = current->le_next;
        std::cout << i << " " << current->value << std::endl;
        ++i;
    }
    std::cout << "" << std::endl;
}

template <typename T>
void destructor_l(list_struct<T>& l)
{
    list_element<T>* current = new list_element<T>;
    current = l.l_begin;
    unsigned int count = size_of_l(l);
    unsigned int counter = 0;
    while (counter != count)
    {
        current = current->le_next;
        delete l.l_begin;
        l.l_begin = current;
        ++counter;
    }
}

int main()
{
    //проверка для int
 list_struct<int> l0;
    constructor_l(l0);
    push_end(l0, 3);
    push_begin(l0, 10);
    push_begin(l0, 4);
    push_end(l0, 9);
    show_list(l0);
    std::cout << find_pos(l0, 3) << std::endl;
    std::cout << find_value(l0, 2) << std::endl;
    std::cout << size_of_l(l0) << std::endl;
    insert_index(l0, 23, 3);
    push_end(l0, 88);
    show_list(l0);
    std::cout << pop_end(l0) << std::endl;
    std::cout << pop_begin(l0) << std::endl;
    show_list(l0);
    push_end(l0, 90);
    push_end(l0, 56);
    show_list(l0);
    std::cout << size_of_l(l0) << std::endl;
    std::cout << pop_index(l0, 2) << std::endl;
    show_list(l0);
    destructor_l(l0);
    //проверка для пользовательского типа
    VVS vvs0, vvs1, vvs2, vvs3;
    vvs0.vvs_number = 35;
    vvs0.name = "Harley";
    vvs0.klass = "Phenomenal";
    vvs1.vvs_number = 96;
    vvs1.name = "Sound sad";
    vvs1.klass = "AC/DC";
    vvs2.vvs_number = 666;
    vvs2.name = "";
    vvs2.klass = "Razor edge";
    vvs3.vvs_number = 343;
    vvs3.name = "Thunderstruck";
    vvs3.klass = "Slim Shady";
   list_struct<VVS> l1;
    constructor_l(l1);
    push_begin(l1, vvs0);
    push_end(l1, vvs1);
    push_begin(l1, vvs2);
    show_list(l1);
    std::cout << find_pos(l1, vvs0) << std::endl;
    std::cout << find_value(l1, 2) << std::endl;
    std::cout << size_of_l(l1) << std::endl;
    insert_index(l1, vvs3, 2);
    show_list(l1);
    std::cout << pop_end(l1);
    std::cout << pop_begin(l1);
    show_list(l1);
    destructor_l(l1);
    return 0;
}
